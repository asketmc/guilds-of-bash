ISTQB Compliance Report — Unit Tests (core-test)

Date: 2026-01-21

Summary
-------
- Module checked: `core-test` (unit tests)
- Test runner executed: `:core-test:test`
- Test results: FAIL — 2 failing tests, see details below.
- Report files generated by Gradle:
  - HTML report: `core-test/build/reports/tests/test/index.html`
  - JUnit XML: `core-test/build/test-results/test/` (multiple `TEST-*.xml` files)

Scope of compliance check
------------------------
Checked items (per your request):
- Test naming (descriptiveness / level tags)
- AAA structure (Arrange / Act / Assert)
- Presence of preconditions and expected-result comments
- Determinism (use of seeded RNG / deterministic state)
- Absence of external dependencies in unit tests
- Coverage by test level (P1 labeling convention)

High-level findings
-------------------
1) Test runner outcome
   - Two failing tests (both in `test.P1_PoCScenarioTest`):
     - `happy path no invariant violations with fee escrow and trophy flow()`
       - Failure: expected reserved fee 200 but observed 0
       - Location in test: `core-test/src/test/kotlin/test/P1_PoCScenarioTest.kt:291`
     - `poc scenario basic contract flow end to end()`
       - Failure: expected that `board` contains a posted contract after `PostContract` but it does not
       - Location in test: `core-test/src/test/kotlin/test/P1_PoCScenarioTest.kt:50`
   - These failures indicate functional mismatch between test assumptions and current core behavior (likely around `PostContract`/escrow semantics and/or inbox->board transition logic).

2) Naming
   - Tests are consistently named with descriptive names and many use human-readable string tests (Kotlin `fun "..."` style).
   - Files are prefixed with `P1_` which documents test priority/level.
   - Recommendation: consider adding an explicit annotation or a short doc comment on each file explaining the `P1` meaning (e.g., `@TestLevel(P1)` or a one-line comment) to make automated classification easier.

3) AAA (Arrange/Act/Assert)
   - Most tests follow an AAA pattern in practice. Many tests include clear `GIVEN/WHEN/THEN` or inline comments that match AAA.
   - Some short tests (especially hashing/serialization unit checks) do not include explicit step comments but maintain short, clear structure.
   - Recommendation: add a tiny three-line comment header inside tests that are more complex to explicitly separate Arrange/Act/Assert for reviewers and traceability.

4) Preconditions & expected results in comments
   - Many test files start with a file-level purpose comment and many tests include `GIVEN/WHEN/THEN` comments (for example in `P1_FeeEscrowTest`, `P1_PoCScenarioTest`, `P1_TrophyPipelineTest`).
   - A few tests (mostly trivial assertions) lack an explicit "preconditions/expected result" comment (for example, some hashing tests and small structure checks). These are low severity.
   - Recommendation: add a short `// GIVEN ...` and `// THEN ...` line to tests that assert non-trivial business logic or rely on a complex state setup.

5) Determinism
   - Tests use seeded `Rng(seed)` and `initialState(seed)` consistently where randomness or state seeding is needed. This is good and satisfies determinism requirements.
   - A note in `P1_HashingTest` documents that `arrivalsToday` is not serialized and thus hash behavior is documented; good practice.
   - Recommendation: ensure all tests that exercise RNG pass an explicit seed and avoid using system time or unseeded RNG anywhere in `core-test`.

6) External dependencies
   - I did not find any network calls, file-system access (beyond in-memory state), or external services in the unit tests. Tests operate purely in-memory and use deterministic RNG.
   - Gradle-runner itself writes reports but tests do not contact external services. Good.

7) Coverage by levels
   - Tests are labeled with `P1_` filename prefix indicating the highest-priority unit tests. The codebase currently contains only `P1` tests (no `P2`/`P3` present in `core-test`).
   - Recommendation: if you rely on multi-level test coverage (ISTQB-like mapping), add a short table in each test file header indicating scope (unit/integration), priority (P1/P2), and mapped requirement ids if applicable.

Detailed failing test information
--------------------------------
(Extracted from Gradle JUnit XML)

1) test.P1_PoCScenarioTest - `happy path no invariant violations with fee escrow and trophy flow()`
   - Assertion failure: expected reserved fee 200 but actual reserved was 0
   - Failure location: `core-test/src/test/kotlin/test/P1_PoCScenarioTest.kt:291`
   - Implication: The test expects `PostContract(inboxId, fee=200)` to cause `state.economy.reservedCopper == 200` after posting. The actual implementation either did not reserve the fee, rejected the post (e.g., invalid state), or has different escrow semantics (e.g., fees only reserved on board->take or fee is applied later).
   - Recommendation (next steps):
     - Inspect `core.canApply` and `core.step` handling for `PostContract` to confirm whether escrow should be applied at Post time. If the intended behavior is to escrow at post, update implementation (core) to reserve fee, then re-run tests. If the intended behavior is different, update the test to reflect the correct semantics and add an explanatory comment referencing the design decision.
     - For safety do not change business logic inside tests. Put any implementation changes in core code with unit tests; if you prefer test-side change, document it.

2) test.P1_PoCScenarioTest - `poc scenario basic contract flow end to end()`
   - Assertion failure: "Board should have posted contract" at P1_PoCScenarioTest.kt:50
   - Implication: After `PostContract`, the test expects the contract to be moved from `inbox` to `board`. The implementation did not produce that result (likely rejected or no-op).
   - Recommendation: same as above — check `PostContract` processing path. Confirm validation, available funds, and whether posting moves contract to board immediately.

Other observations (non-blocking)
--------------------------------
- Many tests call `filterNot { it is InvariantViolated }` before making assertions. That is a reasonable pattern to ignore invariant violation noise in event lists, but for ISTQB traceability it may be better to assert there are no unexpected invariant violations explicitly somewhere in the happy-path tests.
- Some tests rely on implementation details such as exact number of generated inbox contracts (two) and hero counts (two). If these counts are stable by design, keep them; otherwise, consider relaxing assertions or adding explicit comments that these are design invariants.
- A small number of tests have soft-coded magic numbers (e.g., initial money 100). These are fine when part of documented domain constants; consider adding a central constants file or referencing `initialState` invariants to avoid duplication.

Recommended next actions (priority order)
----------------------------------------
1) Investigate the two failing tests by inspecting `PostContract` and escrow handling in `core` module. Decide whether tests or implementation reflect the intended spec.
   - If implementation is wrong (escrow should happen at post), fix core code and rerun `:core-test:test`.
   - If tests are wrong (spec updated), update tests and add comments documenting the expected behavior.

2) Add a short README for `core-test` (or extend this file) describing test structure and P1 meaning, and where to find the test reports (I can add this doc if you want).

3) Make minor consistency improvements (optional but low-risk):
   - Add explicit `// GIVEN / WHEN / THEN` comments to the handful of tests that lack them (particularly those that are long or exercise multiple steps).
   - Add a header comment to each `P1_*.kt` file describing scope, requirement mapping, and acceptance criteria.

4) Re-run `./gradlew :core-test:test` after any implementation or test edits and confirm green test run.

Suggested content for an implementation fix (if escrow behavior is indeed a bug)
-------------------------------------------------------------------------------
- Check `core.step` handling of `PostContract`: when command is accepted, reduce `available` or increase `reservedCopper` by `fee`. Ensure `Validation` allows posting when sufficient available funds exist.
- Ensure `canApply` mirrors the same calculation used in `step`.
- Add a focused unit test in `P1_FeeEscrowTest` to assert escrow behavior (already exists but failing PoC suggests broader path not covered).

Deliverables produced
---------------------
- `ISTQB_COMPLIANCE_REPORT.md` (this file) placed at project root.

If you want me to proceed with any of the following (pick one or more):
- Update core implementation to match the tests (reserve fee at PostContract).
- Update failing tests to reflect current implementation and document the intended semantics.
- Add small formatting/comments improvements across `core-test` (add GIVEN/WHEN/THEN and file headers).

If you confirm which of the three actions above you prefer, I will implement it and re-run `:core-test:test` until green (or report remaining failures and next steps).
